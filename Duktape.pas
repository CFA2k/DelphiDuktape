unit Duktape;

{$INCLUDE 'Grijjy.inc'}

{$MINENUMSIZE 4}

interface

uses
  System.SysUtils,
  Duktape.Api;

const
  DT_VARARGS = DUK_VARARGS;

type
  { Type for (fatal) error generated by the Duktape library. }
  EdtError = class(Exception);

type
  { Internal Duktape strings are UTF8 strings. }
  DuktapeString = UTF8String;

type
  TdtThreadState = record
  {$REGION 'Internal Declarations'}
  public
    _Data: array [0..SizeOf(TDukThreadState) - 1] of Byte;
  {$ENDREGION 'Internal Declarations'}
  end;

type
  TdtMemoryFunctions = TDukMemoryFunctions;
  TdtTimeComponents = TDukTimeComponents;
  TdtFunctionListEntry = TDukFunctionListEntry;
  TdtNumberListEntry = TDukNumberListEntry;

  PdtFunctionListEntry = PDukFunctionListEntry;
  PdtNumberListEntry = PDukNumberListEntry;

type
  TdtErrCode = (
    None = DUK_ERR_NONE,
    Error = DUK_ERR_ERROR,
    EvalError = DUK_ERR_EVAL_ERROR,
    RangeError = DUK_ERR_RANGE_ERROR,
    ReferenceError = DUK_ERR_REFERENCE_ERROR,
    SyntaxError = DUK_ERR_SYNTAX_ERROR,
    TypeError = DUK_ERR_TYPE_ERROR,
    UriError = DUK_ERR_URI_ERROR);

type
  { Result for functions implemented in Delphi }
  TdtResult = (
    { The Delphi function left a return value on the stack. }
    HasResult = 1,

    { The Delphi function did not leave a return value (it behaved like a
      procedure) }
    NoResult = 0,

    { Generic error }
    Error = DUK_RET_ERROR,

    { Evaluation error }
    EvalError = DUK_RET_EVAL_ERROR,

    { Range error }
    RangeError = DUK_RET_RANGE_ERROR,

    { Reference error }
    ReferenceError = DUK_RET_REFERENCE_ERROR,

    { Syntax error }
    SyntaxError = DUK_RET_SYNTAX_ERROR,

    { Type error }
    TypeError = DUK_RET_TYPE_ERROR,

    { URI error }
    UriError = DUK_RET_URI_ERROR);

type
  TdtGCFlag = (Compact = 0);
  TdtGCFlags = set of TdtGCFlag;

type
  TdtBufferType = (
    ArrayBuffer = DUK_BUFOBJ_ARRAYBUFFER,
    NodeJSBuffer = DUK_BUFOBJ_NODEJS_BUFFER,
    DataView = DUK_BUFOBJ_DATAVIEW,
    Int8Array = DUK_BUFOBJ_INT8ARRAY,
    UInt8Array = DUK_BUFOBJ_UINT8ARRAY,
    UInt8ClampedArray = DUK_BUFOBJ_UINT8CLAMPEDARRAY,
    Int16Array = DUK_BUFOBJ_INT16ARRAY,
    UInt16Array = DUK_BUFOBJ_UINT16ARRAY,
    Int32Array = DUK_BUFOBJ_INT32ARRAY,
    UInt32Array = DUK_BUFOBJ_UINT32ARRAY,
    Float32Array = DUK_BUFOBJ_FLOAT32ARRAY,
    Float64Array = DUK_BUFOBJ_FLOAT64ARRAY);

type
  TdtType = (
    None = DUK_TYPE_NONE,
    Undefined = DUK_TYPE_UNDEFINED,
    Null = DUK_TYPE_NULL,
    Boolean = DUK_TYPE_BOOLEAN,
    Number = DUK_TYPE_NUMBER,
    Str = DUK_TYPE_STRING,
    Obj = DUK_TYPE_OBJECT,
    Buffer = DUK_TYPE_BUFFER,
    Pointer = DUK_TYPE_POINTER,
    LightFunc = DUK_TYPE_LIGHTFUNC);
  TdtTypes = set of TdtType;

type
  TdtHint = (
    None = DUK_HINT_NONE,
    Str = DUK_HINT_STRING,
    Number = DUK_HINT_NUMBER);

type
  TgtDefPropFlag = (
    Writable = 0,
    Enumerable = 1,
    Configurable = 2,
    HaveWritable = 3,
    HaveEnumerable = 4,
    HaveConfigurable = 5,
    HaveValue = 6,
    HaveGetter = 7,
    HaveSetter = 8,
    Force = 9);
  TgtDefPropFlags = set of TgtDefPropFlag;

type
  TdtEnumFlag = (
    IncludeNonEnumerable = 0,
    IncludeHidden = 1,
    IncludeSymbols = 2,
    ExcludeStrings = 3,
    OwnPropertiesOnly = 4,
    ArrayIndicesOnly = 5,
    SortArrayIndices = 6,
    NoProxyBehavior = 7);
  TdtEnumFlags = set of TdtEnumFlag;

type
  TdtCompileFlag = (
    Eval = 3,
    Func = 4,
    Strict = 5,
    Shebang = 6,
    Safe = 7,
    NoResult = 8,
    NoSource = 9,
    StrLen = 10,
    NoFilename = 11,
    FuncExpr = 12);
  TdtCompileFlags = set of TdtCompileFlag;

type
  TdtDecodeCharCallback = procedure(const AUserData: Pointer;
    const ACodePoint: Integer); cdecl;

  TdtMapCharCallback = function(const AUserData: Pointer;
    const ACodePoint: Integer): Integer; cdecl;

type
  { Medium-level Duktape class. }
  TDuktape = record
  {$REGION 'Internal Declarations'}
  private
    FContext: PDukContext;
  private
    class function DelphiAlloc(AUserData: Pointer; ASize: TDukSize): Pointer; cdecl; static;
    class function DelphiRealloc(AUserData: Pointer; APtr: Pointer; ASize: TDukSize): Pointer; cdecl; static;
    class procedure DelphiFree(AUserData: Pointer; APtr: Pointer); cdecl; static;
    class procedure FatalHandler(AUserData: Pointer; const AMsg: MarshaledAString); cdecl; static;
  {$ENDREGION 'Internal Declarations'}
  public
    (*** Context management ***)

    { Creates a new Duktape context and heap.

      Parameters:
        AUseDelphiMemoryManager: whether to use Delphi's memory manager.
          When False (default), the system memory manager is used. Set to True
          to have Delphi manage all memory (de)allocations for Duktape. That is
          useful if you want to check for memory leaks using the
          ReportMemoryLeaksOnShutdown global variable. }
    class function Create(const AUseDelphiMemoryManager: Boolean = False): TDuktape; static;

    { Destroys the Duktape context and heap. }
    procedure Free;

    function Suspend: TdtThreadState;
    procedure Resume(const AState: TdtThreadState);
  public
    (*** Memory management
         Raw functions have no side effects (cannot trigger GC). ***)
    function AllocRaw(const ASize: NativeInt): Pointer;
    procedure FreeRaw(const APtr: Pointer);
    function ReallocRaw(const APtr: Pointer; const ASize: NativeInt): Pointer;
    function AllocMem(const ASize: NativeInt): Pointer;
    procedure FreeMem(const APtr: Pointer);
    function ReallocMem(const APtr: Pointer; const ASize: NativeInt): Pointer;
    function GetMemoryManagementFunctions: TdtMemoryFunctions;
    procedure GarbageCollect(const AFlags: TdtGCFlags = []);
  public
    (*** Error handling ***)
    procedure Throw;
    procedure Fatal(const AErrMsg: DuktapeString);
    procedure Error(const AErrCode: TdtErrCode; const AErrMsg: DuktapeString);
    procedure GenericError(const AErrMsg: DuktapeString);
    procedure EvalError(const AErrMsg: DuktapeString);
    procedure RangeError(const AErrMsg: DuktapeString);
    procedure ReferenceError(const AErrMsg: DuktapeString);
    procedure SyntaxError(const AErrMsg: DuktapeString);
    procedure TypeError(const AErrMsg: DuktapeString);
    procedure UriError(const AErrMsg: DuktapeString);
  public
    (*** Other state related functions ***)
    function IsStrictCall: Boolean;
    function IsConstructorCall: Boolean;
  public
    (*** Stack management ***)
    function NormalizeIndex(const AIndex: Integer): Integer;
    function RequireNormalizeIndex(const AIndex: Integer): Integer;
    function IsValidIndex(const AIndex: Integer): Boolean;
    procedure RequireValidIndex(const AIndex: Integer);

    { Get current stack top (>= 0), indicating the number of values currently on
      the value stack (of the current activation). }
    function GetTop: Integer;

    procedure SetTop(const AIndex: Integer);
    function GetTopIndex: Integer;
    function RequireTopIndex: Integer;

    function CheckStack(const AExtra: Integer): Boolean;
    procedure RequireStack(const AExtra: Integer);
    function CheckStackTop(const ATop: Integer): Boolean;
    procedure RequireStackTop(const ATop: Integer);
  public
    (*** Stack manipulation (other than push/pop) ***)
    procedure Swap(const AIndex1, AIndex2: Integer);
    procedure SwapTop(const AIndex: Integer);
    procedure Dup(const AFromIndex: Integer);
    procedure DupTop;

    { Insert a value at AToIndex with a value popped from the stack top. The
      previous value at AToIndex and any values above it are moved up the
      stack by a step. If AToIndex is an invalid index, throws an error.

      Negative indices are evaluated prior to popping the value at the stack
      top. }
    procedure Insert(const AToIndex: Integer);

    procedure Replace(const AToIndex: Integer);
    procedure Copy(const AFromIndex, AToIndex: Integer);
    procedure Remove(const AIndex: Integer);

    procedure XMoveTop(const AToContext: TDuktape; const ACount: Integer);
    procedure XCopyTop(const AToContext: TDuktape; const ACount: Integer);
  public
    (*** Push operations

         Push functions return the absolute (relative to bottom of frame)
         position of the pushed value for convenience.

         Note: Dup is technically a push. ***)

    procedure PushUndefined;
    procedure PushNull;
    procedure PushBoolean(const AValue: Boolean);
    procedure PushTrue;
    procedure PushFalse;
    procedure PushNumber(const AValue: Double);
    procedure PushNan;
    procedure PushInt(const AValue: Integer);
    procedure PushUInt(const AValue: Cardinal);

    { Push a string to the stack. The string may contain arbitrary data,
      including internal NUL characters. A pointer to the interned string data
      is returned. If the operation fails, throws an error.

      The returned pointer can be dereferenced and a NUL terminator character is
      guaranteed. }
    function PushString(const AString: DuktapeString): MarshaledAString;

    procedure PushPointer(const AValue: Pointer);

    procedure PushThis;
    procedure PushCurrentFunction;
    procedure PushCurrentThread;
    procedure PushGlobalObject;
    procedure PushHeapStash;
    procedure PushGlobalStash;
    procedure PushThreadStash(const ATargetContext: TDuktape);

    function PushObject: Integer;
    function PushBareObject: Integer;
    function PushArray: Integer;

    function PushThread: Integer;
    function PushThreadNewGlobalEnv: Integer;

    function PushProxy(const AFlags: Cardinal): Integer;

    function PushErrorObject(const AErrCode: TdtErrcode; const AErrMsg: DuktapeString): Integer;

    function PushBuffer(const ASize: NativeInt; const AIsDynamic: Boolean): Pointer;
    function PushFixedBuffer(const ASize: NativeInt): Pointer;
    function PushDynamicBuffer(const ASize: NativeInt): Pointer;
    function PushExternalBuffer: Pointer;

    procedure PushBufferObject(const ABufferIndex: Integer;
      const AByteOffset, AByteLength: NativeInt; const AType: TdtBufferType);

    function PushHeapPtr(const APtr: Pointer): Integer;
  public
    (*** Pop operations ***)
    procedure Pop; overload;
    procedure Pop(const ACount: Integer); overload;
    procedure Pop2;
    procedure Pop3;
  public
    (*** Type checks
         IsNone, which would indicate whether index it outside of stack,
         is not needed; IsValidIndex gives the same information. ***)
    function GetType(const AIndex: Integer): TdtType;
    function CheckType(const AIndex: Integer; const AType: TdtType): Boolean;
    function GetTypes(const AIndex: Integer): TdtTypes;
    function CheckTypes(const AIndex: Integer; const ATypes: TdtTypes): Boolean;

    function IsUndefined(const AIndex: Integer): Boolean;
    function IsNull(const AIndex: Integer): Boolean;
    function IsNullOrUndefined(const AIndex: Integer): Boolean;

    function IsBoolean(const AIndex: Integer): Boolean;
    function IsNumber(const AIndex: Integer): Boolean;
    function IsNan(const AIndex: Integer): Boolean;
    function IsString(const AIndex: Integer): Boolean;
    function IsObject(const AIndex: Integer): Boolean;
    function IsBuffer(const AIndex: Integer): Boolean;
    function IsBufferData(const AIndex: Integer): Boolean;
    function IsPointer(const AIndex: Integer): Boolean;
    function IsLightFunc(const AIndex: Integer): Boolean;

    function IsSymbol(const AIndex: Integer): Boolean;
    function IsArray(const AIndex: Integer): Boolean;
    function IsFunction(const AIndex: Integer): Boolean;
    function IsDelphiFunction(const AIndex: Integer): Boolean;
    function IsEcmaScriptFunction(const AIndex: Integer): Boolean;
    function IsBoundFunction(const AIndex: Integer): Boolean;
    function IsThread(const AIndex: Integer): Boolean;
    function IsCallable(const AIndex: Integer): Boolean;
    function IsConstructable(const AIndex: Integer): Boolean;

    function IsDynamicBuffer(const AIndex: Integer): Boolean;
    function IsFixedBuffer(const AIndex: Integer): Boolean;
    function IsExternalBuffer(const AIndex: Integer): Boolean;

    function IsPrimitive(const AIndex: Integer): Boolean;
    function IsObjectCoercible(const AIndex: Integer): Boolean;

    function GetErrorCode(const AIndex: Integer): TdtErrcode;
    function IsError(const AIndex: Integer): Boolean;
    function IsEvalError(const AIndex: Integer): Boolean;
    function IsRangeError(const AIndex: Integer): Boolean;
    function IsReferenceError(const AIndex: Integer): Boolean;
    function IsSyntaxError(const AIndex: Integer): Boolean;
    function IsTypeError(const AIndex: Integer): Boolean;
    function IsUriError(const AIndex: Integer): Boolean;
  public
    (*** Get operations: no coercion, returns default value for invalid
         indices and invalid value types.

         GetUndefined and GetNull would be pointless and are not included. ***)
    function GetBoolean(const AIndex: Integer): Boolean; overload;
    function GetBoolean(const AIndex: Integer; const ADefault: Boolean): Boolean; overload;
    function GetNumber(const AIndex: Integer): Double; overload;
    function GetNumber(const AIndex: Integer; const ADefault: Double): Double; overload;
    function GetInt(const AIndex: Integer): Integer; overload;
    function GetInt(const AIndex: Integer; const ADefault: Integer): Integer; overload;
    function GetUInt(const AIndex: Integer): Cardinal; overload;
    function GetUInt(const AIndex: Integer; const ADefault: Cardinal): Cardinal; overload;
    function GetString(const AIndex: Integer): DuktapeString; overload;
    function GetString(const AIndex: Integer; const ADefault: DuktapeString): DuktapeString; overload;
    function GetBuffer(const AIndex: Integer; out ASize: NativeInt): Pointer; overload;
    function GetBuffer(const AIndex: Integer; out ASize: NativeInt;
      const ADefault: Pointer; const ADefaultSize: NativeInt): Pointer; overload;
    function GetBufferData(const AIndex: Integer; out ASize: NativeInt): Pointer; overload;
    function GetBufferData(const AIndex: Integer; out ASize: NativeInt;
      const ADefault: Pointer; const ADefaultSize: NativeInt): Pointer; overload;
    function GetPointer(const AIndex: Integer): Pointer; overload;
    function GetPointer(const AIndex: Integer; const ADefault: Pointer): Pointer; overload;
    function GetContext(const AIndex: Integer): TDuktape; overload;
    function GetContext(const AIndex: Integer; const ADefault: TDuktape): TDuktape; overload;
    function GetHeapPtr(const AIndex: Integer): Pointer; overload;
    function GetHeapPtr(const AIndex: Integer; const ADefault: Pointer): Pointer; overload;
  public
    (*** Opt operations: like require operations but with an explicit default
         value when value is undefined or index is invalid, null and
         non-matching types cause a TypeError. ***)
    function OptBoolean(const AIndex: Integer; const ADefault: Boolean): Boolean;
    function OptNumber(const AIndex: Integer; const ADefault: Double): Double;
    function OptInt(const AIndex: Integer; const ADefault: Integer): Integer;
    function OptUInt(const AIndex: Integer; const ADefault: Cardinal): Cardinal;
    function OptString(const AIndex: Integer; const ADefault: DuktapeString): DuktapeString;
    function OptBuffer(const AIndex: Integer; out ASize: NativeInt;
      const ADefault: Pointer; const ADefaultSize: NativeInt): Pointer;
    function OptBufferData(const AIndex: Integer; out ASize: NativeInt;
      const ADefault: Pointer; const ADefaultSize: NativeInt): Pointer;
    function OptPointer(const AIndex: Integer; const ADefault: Pointer): Pointer;
    function OptContext(const AIndex: Integer; const ADefault: TDuktape): TDuktape;
    function OptHeapPtr(const AIndex: Integer; const ADefault: Pointer): Pointer;
  public
    (*** Require operations: no coercion, throw error if index or type
         is incorrect.  No defaulting. ***)
    procedure RequireTypes(const AIndex: Integer; const ATypes: TdtTypes);

    procedure RequireUndefined(const AIndex: Integer);
    procedure RequireNull(const AIndex: Integer);
    function RequireBoolean(const AIndex: Integer): Boolean;
    function RequireNumber(const AIndex: Integer): Double;
    function RequireInt(const AIndex: Integer): Integer;
    function RequireUInt(const AIndex: Integer): Cardinal;
    function RequireString(const AIndex: Integer): DuktapeString;
    procedure RequireObject(const AIndex: Integer);
    function RequireBuffer(const AIndex: Integer; out ASize: NativeInt): Pointer;
    function RequireBufferData(const AIndex: Integer; out ASize: NativeInt): Pointer;
    function RequirePointer(const AIndex: Integer): Pointer;
    function RequireContext(const AIndex: Integer): TDuktape;
    procedure RequireFunction(const AIndex: Integer);
    procedure RequireCallable(const AIndex: Integer);
    function RequireHeapPtr(const AIndex: Integer): Pointer;
    procedure RequireObjectCoercible(const AIndex: Integer);
  public
    (*** Coercion operations: in-place coercion, return coerced value where
         applicable.  If AIndex is invalid, throw error.  Some coercions may
         throw an expected error (e.g. from a ToString or ValueOf call)
         or an internal error (e.g. from out of memory). ***)
    procedure ToUndefined(const AIndex: Integer);
    procedure ToNull(const AIndex: Integer);
    function ToBoolean(const AIndex: Integer): Boolean;
    function ToNumber(const AIndex: Integer): Double;
    function ToInt(const AIndex: Integer): Integer;
    function ToUInt(const AIndex: Integer): Cardinal;
    function ToInt32(const AIndex: Integer): Integer;
    function ToUInt32(const AIndex: Integer): Cardinal;
    function ToUInt16(const AIndex: Integer): UInt16;
    function ToString(const AIndex: Integer): DuktapeString;
    function ToPointer(const AIndex: Integer): Pointer;
    procedure ToObject(const AIndex: Integer);
    procedure ToPrimitive(const AIndex: Integer; const AHint: TdtHint);
    function ToBuffer(const AIndex: Integer; out ASize: NativeInt): Pointer;
    function ToFixedBuffer(const AIndex: Integer; out ASize: NativeInt): Pointer;
    function ToDynamicBuffer(const AIndex: Integer; out ASize: NativeInt): Pointer;

    { Like ToString but if the initial string coercion fails, the error value is
      coerced to a string. If that also fails, a fixed error string is returned.

      The caller can safely use this function to coerce a value to a string,
      which is useful in Delphi code to print out a return value safely. The
      only uncaught errors possible are out-of-memory and other internal errors
      which trigger fatal error handling anyway. }
    function SafeToString(const AIndex: Integer): DuktapeString;
  public
    (***  Value length ***)
    function GetLength(const AIndex: Integer): NativeInt;
    procedure SetLength(const AIndex: Integer; const ALength: NativeInt);
  public
    (***  Misc conversion **)
    function Base64Encode(const AIndex: Integer): DuktapeString;
    procedure Base64Decode(const AIndex: Integer);
    function HexEncode(const AIndex: Integer): DuktapeString;
    procedure HexDecode(const AIndex: Integer);
    function JsonEncode(const AIndex: Integer): DuktapeString;
    procedure JsonDecode(const AIndex: Integer);

    function BufferToString(const AIndex: Integer): DuktapeString;
  public
    (*** Buffer ***)
    function Resize_buffer(const AIndex: Integer; const ANewSize: NativeInt): Pointer;
    function StealBuffer(const AIndex: Integer; out ASize: NativeInt): Pointer;
    procedure ConfigBuffer(const AIndex: Integer; const APtr: Pointer; const ALen: NativeInt);
  public
    (*** Property access

         The basic function assumes key is on stack.  The String variant takes
         a string as a property name, while the Index variant takes an array
         index as a property name (e.g. 123 is equivalent to the key "123"). ***)
    function GetProp(const AObjIndex: Integer): Boolean; overload;
    function GetProp(const AObjIndex: Integer; const AKey: DuktapeString): Boolean; overload;
    function GetProp(const AObjIndex, AArrIndex: Integer): Boolean; overload;
    function GetProp(const AObjIndex: Integer; const APtr: Pointer): Boolean; overload;
    function PutProp(const AObjIndex: Integer): Boolean; overload;
    function PutProp(const AObjIndex: Integer; const AKey: DuktapeString): Boolean; overload;
    function PutProp(const AObjIndex, AArrIndex: Integer): Boolean; overload;
    function PutProp(const AObjIndex: Integer; const APtr: Pointer): Boolean; overload;
    function DelProp(const AObjIndex: Integer): Boolean; overload;
    function DelProp(const AObjIndex: Integer; const AKey: DuktapeString): Boolean; overload;
    function DelProp(const AObjIndex, AArrIndex: Integer): Boolean; overload;
    function DelProp(const AObjIndex: Integer; const APtr: Pointer): Boolean; overload;
    function HasProp(const AObjIndex: Integer): Boolean; overload;
    function HasProp(const AObjIndex: Integer; const AKey: DuktapeString): Boolean; overload;
    function HasProp(const AObjIndex, AArrIndex: Integer): Boolean; overload;
    function HasProp(const AObjIndex: Integer; const APtr: Pointer): Boolean; overload;

    procedure GetPropDesc(const AObjIndex: Integer);
    procedure DefProp(const AObjIndex: Integer; const AFlags: TgtDefPropFlags);

    function GetGlobalString(const AKey: DuktapeString): Boolean;

    { Put property named AKey to the global object. Return value behaves
      similarly to PutProp. This is a convenience function which does the
      equivalent of:

      <source>
      Duktape.PushGlobalObject;
      Duktape.Insert(-2);
      Result := Duktape.PutPropString(-2, AKey);
      Duktape.Pop;
      </source> }
    function PutGlobalString(const AKey: DuktapeString): Boolean;
  public
    (*** Inspection ***)
    procedure InspectValue(const AIndex: Integer);
    procedure InspectCallstackEntry(const ALevel: Integer);
  public
    (*** Object prototype ***)
    procedure GetPrototype(const AIndex: Integer);
    procedure SetPrototype(const AIndex: Integer);
  public
    (*** Object finalizer ***)
    procedure GetFinalizer(const AIndex: Integer);
    procedure SetFinalizer(const AIndex: Integer);
  public
    (*** Global object ***)
    procedure SetGlobalObject;
  public
    (*** Duktape/Delphi function magic value ***)
    function GetMagic(const AIndex: Integer): Integer;
    procedure SetMagic(const AIndex: Integer; const AMagic: Integer);
    function GetCurrentMagic: Integer;
  public
    (*** Module helpers: put multiple function or constant properties ***)
    procedure PutFunctionList(const AObjIndex: Integer;
      const AFunctions: PdtFunctionListEntry);
    procedure PutNumberList(const AObjIndex: Integer;
      const ANumbers: PdtNumberListEntry);
  public
    (*** Object operations ***)
    procedure Compact(const AObjIndex: Integer);
    procedure Enum(const AObjIndex: Integer; const AFlags: TdtEnumFlags);
    function Next(const AEnumIndex: Integer; const AGetValue: Boolean): Boolean;
    procedure Seal(const AObjIndex: Integer);
    procedure Freeze(const AObjIndex: Integer);
  public
    (*** String manipulation ***)

    procedure Concat(const ACount: Integer);

    { Join zero or more values into a result string with a separator between
      each value. The separator and the input values are automatically coerced
      with ToString.

      This primitive minimizes the number of intermediate string interning
      operations and is better than joining strings manually. }
    procedure Join(const ACount: Integer);

    procedure DecodeString(const AIndex: Integer;
      const ACallback: TdtDecodeCharCallback; const AUserData: Pointer);
    procedure MapString(const AIndex: Integer;
      const ACallback: TdtMapCharCallback; const AUserData: Pointer);
    procedure SubString(const AIndex: Integer; const AStartCharOffset,
      AEndCharOffset: NativeInt);
    function CharCodeAt(const AIndex: Integer; const ACharOffset: NativeInt): Integer;
  public
    (*** Ecmascript operators ***)
    function Equals(const AIndex1, AIndex2: Integer): Boolean;
    function StrictEquals(const AIndex1, AIndex2: Integer): Boolean;
    function SameValue(const AIndex1, AIndex2: Integer): Boolean;
    function InstanceOf(const AIndex1, AIndex2: Integer): Boolean;
  public
    (*** Function (method) calls ***)
    procedure Call(const ANumArgs: Integer);
    procedure CallMethod(const ANumArgs: Integer);
    procedure CallProp(const AObjIndex, ANumArgs: Integer);
    function ProtectedCall(const ANumArgs: Integer): Integer;
    function ProtectedCallMethod(const ANumArgs: Integer): Integer;
    function ProtectedCallProp(const AObjIndex, ANumArgs: Integer): Integer;
    procedure New(const ANumArgs: Integer);
    function ProtectedNew(const ANumArgs: Integer): Integer;
  public
    (*** Compilation and evaluation ***)

    function Eval: Integer; overload;
    function Eval(const ASource: DuktapeString): Integer; overload;
    function EvalNoResult: Integer; overload;
    function EvalNoResult(const ASource: DuktapeString): Integer; overload;
    function ProtectedEval: Integer; overload;
    function ProtectedEval(const ASource: DuktapeString): Integer; overload;
    function ProtectedEvalNoResult: Integer; overload;
    function ProtectedEvalNoResult(const ASource: DuktapeString): Integer; overload;
    function Compile(const AFlags: TdtCompileFlags): Integer; overload;
    function Compile(const AFlags: TdtCompileFlags; const ASource: DuktapeString): Integer; overload;
    function CompileFilename(const AFlags: TdtCompileFlags; const ASource: DuktapeString): Integer;
    function ProtectedCompile(const AFlags: TdtCompileFlags): Integer; overload;
    function ProtectedCompile(const AFlags: TdtCompileFlags; const ASource: DuktapeString): Integer; overload;
    function ProtectedCompileFilename(const AFlags: TdtCompileFlags; const ASource: DuktapeString): Integer;
  public
    (*** Bytecode load/dump ***)
    procedure DumpFunction;
    procedure LoadFunction;
  public
    (*** Debugging ***)
    procedure PushContextDump;
  public
    (*** Debugger (debug protocol) ***)
    procedure DebuggerDetach;
    procedure DebuggerCooperate;
    function DebuggerNotify(const ANumValues: Integer): Boolean;
    procedure DebuggerPause;
  public
    (*** Time handling ***)
    function GetNow: Double;
    function TimeToComponents(const ATimeVal: Double): TdtTimeComponents;
    function ComponentsToTime(const AComponents: TdtTimeComponents): Double;
  public
    (*** Low level context handle ***)
    property Context: PDukContext read FContext;
  end;

type
  { Function signature for Delphi functions that can be called from JavaScript. }
  TdtDelphiFunction = function(const ADuktape: TDuktape): TdtResult; cdecl;

  TdtSafeCallFunction = function(const ADuktape: TDuktape;
    const AUserData: Pointer): TdtResult; cdecl;

  TdtDebugReadCallback = function(const AUserData: Pointer;
    const ABuffer: MarshaledAString; const ALength: NativeInt): NativeInt; cdecl;

  TdtDebugWriteCallback = function(const AUserData: Pointer;
    const ABuffer: MarshaledAString; const Aength: NativeInt): NativeInt; cdecl;

  TdtDebugPeekCallback = function(const AUserData: Pointer): NativeInt; cdecl;

  TdtDebugReadFlushCallback = procedure(const AUserData: Pointer); cdecl;

  TdtDebugWriteFlushCallback = procedure(const AUserData: Pointer); cdecl;

  TdtDebugRequestCallback = function(const ADuktape: TDuktape;
    const AUserData: Pointer; const ANumValues: Integer): Integer; cdecl;

  TdtDebugDetachedCallback = procedure(const ADuktape: TDuktape;
    const AUserData: Pointer); cdecl;

type
  TDuktapeHelper = record helper for TDuktape
  public
    (*** Push operations ***)

    { Push a new function object, associated with a Delphi function, to the
      stack. The function object is an Ecmascript function object; when called,
      AFunc will be called using the Duktape/C function interface. Returns
      non-negative index (relative to stack bottom) of the pushed function.

      The ANumArgs argument controls how the value stack looks like when AFunc
      is entered:

      If ANumArgs is >= 0, it indicates the exact number of arguments the
      function expects to see; extra arguments are discarded and missing
      arguments are filled in with undefined values. Upon entry to the function,
      value stack top will always match nargs.

      If ANumArgs is set to DT_VARARGS, the value stack will contain actual
      (variable) call arguments and the function needs to check actual argument
      count with GetTop.

      The function created will be callable both as a normal function (AFunc())
      and as a constructor (new AFunc()). You can differentiate between the two
      call styles using IsConstructorCall. Although the function can be used as
      a constructor, it doesn't have an automatic prototype property like
      Ecmascript functions.

      @bold(Note): If you intend to use the pushed function as a constructor,
      you should usually create a prototype object and set the prototype
      property of the function manually. }
    function PushDelphiFunction(const AFunc: TdtDelphiFunction;
      const ANumArgs: Integer): Integer;

    function PushDelphiLightFunction(const AFunc: TdtDelphiFunction;
      const ANumArgs, ALength, AMagic: Integer): Integer;
  public
    (*** Get operations ***)
    function GetDelphiFunction(const AIndex: Integer): TdtDelphiFunction; overload;
    function GetDelphiFunction(const AIndex: Integer; const ADefault: TdtDelphiFunction): TdtDelphiFunction; overload;
  public
    (*** Opt operations ***)
    function OptDelphiFunction(const AIndex: Integer; const ADefault: TdtDelphiFunction): TdtDelphiFunction;
  public
    (*** Require operations ***)
    function RequireDelphiFunction(const AIndex: Integer): TdtDelphiFunction;
  public
    (*** Function (method) calls ***)
    function SafeCall(const AFunc: TdtSafeCallFunction; const AUserData: Pointer;
      const ANumArgs, ANumReturns: Integer): Integer;
  public
    (*** Debugger (debug protocol) ***)
    procedure DebuggerAttach(
      const AReadCallback: TdtDebugReadCallback;
      const AWriteCallback: TdtDebugWriteCallback;
      const APeekCallback: TdtDebugPeekCallback;
      const AReadFlushCallback: TdtDebugReadFlushCallback;
      const AWriteFlushCallback: TdtDebugWriteFlushCallback;
      const ARequestCallback: TdtDebugRequestCallback;
      const ADetachedCallback: TdtDebugDetachedCallback;
      const AUserData: Pointer);
  end;

implementation

{ TDuktape }

function TDuktape.AllocMem(const ASize: NativeInt): Pointer;
begin
  Result := duk_alloc(FContext, ASize);
end;

function TDuktape.AllocRaw(const ASize: NativeInt): Pointer;
begin
  Result := duk_alloc_raw(FContext, ASize);
end;

procedure TDuktape.Base64Decode(const AIndex: Integer);
begin
  duk_base64_decode(FContext, AIndex);
end;

function TDuktape.Base64Encode(const AIndex: Integer): DuktapeString;
begin
  Result := DuktapeString(duk_base64_encode(FContext, AIndex));
end;

function TDuktape.BufferToString(const AIndex: Integer): DuktapeString;
begin
  Result := DuktapeString(duk_buffer_to_string(FContext, AIndex));
end;

procedure TDuktape.Call(const ANumArgs: Integer);
begin
  duk_call(FContext, ANumArgs);
end;

procedure TDuktape.CallMethod(const ANumArgs: Integer);
begin
  duk_call_method(FContext, ANumArgs);
end;

procedure TDuktape.CallProp(const AObjIndex, ANumArgs: Integer);
begin
  duk_call_prop(FContext, AObjIndex, ANumArgs);
end;

function TDuktape.CharCodeAt(const AIndex: Integer;
  const ACharOffset: NativeInt): Integer;
begin
  Result := duk_char_code_at(FContext, AIndex, ACharOffset);
end;

function TDuktape.CheckStack(const AExtra: Integer): Boolean;
begin
  Result := (duk_check_stack(FContext, AExtra) <> 0);
end;

function TDuktape.CheckStackTop(const ATop: Integer): Boolean;
begin
  Result := (duk_check_stack_top(FContext, ATop) <> 0);
end;

function TDuktape.CheckType(const AIndex: Integer;
  const AType: TdtType): Boolean;
begin
  Result := (duk_check_type(FContext, AIndex, Ord(AType)) <> 0);
end;

function TDuktape.CheckTypes(const AIndex: Integer;
  const ATypes: TdtTypes): Boolean;
begin
  Result := (duk_check_type_mask(FContext, AIndex, Word(ATypes)) <> 0);
end;

procedure TDuktape.Compact(const AObjIndex: Integer);
begin
  duk_compact(FContext, AObjIndex);
end;

function TDuktape.Compile(const AFlags: TdtCompileFlags): Integer;
begin
  Result := duk_compile(FContext, Word(AFlags));
end;

function TDuktape.Compile(const AFlags: TdtCompileFlags;
  const ASource: DuktapeString): Integer;
begin
  Result := duk_compile_lstring(FContext, Word(AFlags),
    MarshaledAString(ASource), Length(ASource));
end;

function TDuktape.CompileFilename(const AFlags: TdtCompileFlags;
  const ASource: DuktapeString): Integer;
begin
  Result := duk_compile_lstring_filename(FContext, Word(AFlags),
    MarshaledAString(ASource), Length(ASource));
end;

function TDuktape.ComponentsToTime(
  const AComponents: TdtTimeComponents): Double;
begin
  Result := duk_components_to_time(FContext, @AComponents);
end;

procedure TDuktape.Concat(const ACount: Integer);
begin
  duk_concat(FContext, ACount);
end;

procedure TDuktape.ConfigBuffer(const AIndex: Integer; const APtr: Pointer;
  const ALen: NativeInt);
begin
  duk_config_buffer(FContext, AIndex, APtr, ALen);
end;

procedure TDuktape.Copy(const AFromIndex, AToIndex: Integer);
begin
  duk_copy(FContext, AFromIndex, AToIndex);
end;

class function TDuktape.Create(const AUseDelphiMemoryManager: Boolean): TDuktape;
begin
  if (AUseDelphiMemoryManager) then
    Result.FContext := duk_create_heap(DelphiAlloc, DelphiRealloc, DelphiFree, nil, FatalHandler)
  else
    Result.FContext := duk_create_heap(nil, nil, nil, nil, FatalHandler);

  if (Result.FContext = nil) then
    raise EdtError.Create('Unable to create Duktape heap and context');
end;

procedure TDuktape.DebuggerCooperate;
begin
  duk_debugger_cooperate(FContext);
end;

procedure TDuktape.DebuggerDetach;
begin
  duk_debugger_detach(FContext);
end;

function TDuktape.DebuggerNotify(const ANumValues: Integer): Boolean;
begin
  Result := (duk_debugger_notify(FContext, ANumValues) <> 0);
end;

procedure TDuktape.DebuggerPause;
begin
  duk_debugger_pause(FContext);
end;

procedure TDuktape.DecodeString(const AIndex: Integer;
  const ACallback: TdtDecodeCharCallback; const AUserData: Pointer);
begin
  duk_decode_string(FContext, AIndex, TDukDecodeCharFunction(ACallback), AUserData);
end;

procedure TDuktape.DefProp(const AObjIndex: Integer;
  const AFlags: TgtDefPropFlags);
begin
  duk_def_prop(FContext, AObjIndex, Word(AFlags));
end;

class function TDuktape.DelphiAlloc(AUserData: Pointer;
  ASize: TDukSize): Pointer;
begin
  GetMem(Result, ASize);
end;

class procedure TDuktape.DelphiFree(AUserData, APtr: Pointer);
begin
  System.FreeMem(APtr);
end;

class function TDuktape.DelphiRealloc(AUserData, APtr: Pointer;
  ASize: TDukSize): Pointer;
begin
  Result := APtr;
  System.ReallocMem(Result, ASize);
end;

function TDuktape.DelProp(const AObjIndex: Integer): Boolean;
begin
  Result := (duk_del_prop(FContext, AObjIndex) <> 0);
end;

function TDuktape.DelProp(const AObjIndex, AArrIndex: Integer): Boolean;
begin
  Result := (duk_del_prop_index(FContext, AObjIndex, AArrIndex) <> 0);
end;

function TDuktape.DelProp(const AObjIndex: Integer;
  const AKey: DuktapeString): Boolean;
begin
  Result := (duk_del_prop_string(FContext, AObjIndex, MarshaledAString(AKey)) <> 0);
end;

function TDuktape.DelProp(const AObjIndex: Integer;
  const APtr: Pointer): Boolean;
begin
  Result := (duk_del_prop_heapptr(FContext, AObjIndex, APtr) <> 0);
end;

procedure TDuktape.DumpFunction;
begin
  duk_dump_function(FContext);
end;

procedure TDuktape.Dup(const AFromIndex: Integer);
begin
  duk_dup(FContext, AFromIndex);
end;

procedure TDuktape.DupTop;
begin
  duk_dup_top(FContext);
end;

procedure TDuktape.Enum(const AObjIndex: Integer; const AFlags: TdtEnumFlags);
begin
  duk_enum(FContext, AObjIndex, Byte(AFlags));
end;

function TDuktape.Equals(const AIndex1, AIndex2: Integer): Boolean;
begin
  Result := (duk_equals(FContext, AIndex1, AIndex2) <> 0);
end;

procedure TDuktape.Error(const AErrCode: TdtErrCode;
  const AErrMsg: DuktapeString);
begin
  duk_error(FContext, Ord(AErrCode), MarshaledAString(AErrMsg));
end;

function TDuktape.Eval: Integer;
begin
  Result := duk_eval(FContext);
end;

function TDuktape.Eval(const ASource: DuktapeString): Integer;
begin
  Result := duk_eval_lstring(FContext, MarshaledAString(ASource), Length(ASource));
end;

procedure TDuktape.EvalError(const AErrMsg: DuktapeString);
begin
  duk_eval_error(FContext, MarshaledAString(AErrMsg));
end;

function TDuktape.EvalNoResult(const ASource: DuktapeString): Integer;
begin
  Result := duk_eval_lstring_noresult(FContext, MarshaledAString(ASource), Length(ASource));
end;

function TDuktape.EvalNoResult: Integer;
begin
  Result := duk_eval_noresult(FContext);
end;

procedure TDuktape.Fatal(const AErrMsg: DuktapeString);
begin
  duk_fatal(FContext, MarshaledAString(AErrMsg));
end;

class procedure TDuktape.FatalHandler(AUserData: Pointer;
  const AMsg: MarshaledAString);
begin
  raise EdtError.Create(String(AMsg));
end;

procedure TDuktape.Free;
begin
  if (FContext <> nil) then
    duk_destroy_heap(FContext);
end;

procedure TDuktape.FreeMem(const APtr: Pointer);
begin
  duk_free(FContext, APtr);
end;

procedure TDuktape.FreeRaw(const APtr: Pointer);
begin
  duk_free_raw(FContext, APtr);
end;

procedure TDuktape.Freeze(const AObjIndex: Integer);
begin
  duk_freeze(FContext, AObjIndex);
end;

procedure TDuktape.GarbageCollect(const AFlags: TdtGCFlags);
begin
  duk_gc(FContext, Byte(AFlags));
end;

procedure TDuktape.GenericError(const AErrMsg: DuktapeString);
begin
  duk_generic_error(FContext, MarshaledAString(AErrMsg));
end;

function TDuktape.GetBoolean(const AIndex: Integer): Boolean;
begin
  Result := (duk_get_boolean(FContext, AIndex) <> 0);
end;

function TDuktape.GetBoolean(const AIndex: Integer;
  const ADefault: Boolean): Boolean;
begin
  Result := (duk_get_boolean_default(FContext, AIndex, Ord(ADefault)) <> 0);
end;

function TDuktape.GetBuffer(const AIndex: Integer;
  out ASize: NativeInt): Pointer;
begin
  Result := duk_get_buffer(FContext, AIndex, @ASize);
end;

function TDuktape.GetBuffer(const AIndex: Integer; out ASize: NativeInt;
  const ADefault: Pointer; const ADefaultSize: NativeInt): Pointer;
begin
  Result := duk_get_buffer_default(FContext, AIndex, @ASize, ADefault, ADefaultSize);
end;

function TDuktape.GetBufferData(const AIndex: Integer; out ASize: NativeInt;
  const ADefault: Pointer; const ADefaultSize: NativeInt): Pointer;
begin
  Result := duk_get_buffer_data_default(FContext, AIndex, @ASize, ADefault, ADefaultSize);
end;

function TDuktape.GetBufferData(const AIndex: Integer;
  out ASize: NativeInt): Pointer;
begin
  Result := duk_get_buffer_data(FContext, AIndex, @ASize);
end;

function TDuktape.GetContext(const AIndex: Integer;
  const ADefault: TDuktape): TDuktape;
begin
  Result.FContext := duk_get_context_default(FContext, AIndex, ADefault.FContext);
end;

function TDuktape.GetCurrentMagic: Integer;
begin
  Result := duk_get_current_magic(FContext);
end;

function TDuktape.GetContext(const AIndex: Integer): TDuktape;
begin
  Result.FContext := duk_get_context(FContext, AIndex);
end;

function TDuktape.GetErrorCode(const AIndex: Integer): TdtErrcode;
begin
  Result := TdtErrCode(duk_get_error_code(FContext, AIndex));
end;

procedure TDuktape.GetFinalizer(const AIndex: Integer);
begin
  duk_get_finalizer(FContext, AIndex);
end;

function TDuktape.GetGlobalString(const AKey: DuktapeString): Boolean;
begin
  Result := (duk_get_global_string(FContext, MarshaledAString(AKey)) <> 0);
end;

function TDuktape.GetHeapPtr(const AIndex: Integer): Pointer;
begin
  Result := duk_get_heapptr(FContext, AIndex);
end;

function TDuktape.GetHeapPtr(const AIndex: Integer;
  const ADefault: Pointer): Pointer;
begin
  Result := duk_get_heapptr_default(FContext, AIndex, ADefault);
end;

function TDuktape.GetInt(const AIndex, ADefault: Integer): Integer;
begin
  Result := duk_get_int_default(FContext, AIndex, ADefault);
end;

function TDuktape.GetLength(const AIndex: Integer): NativeInt;
begin
  Result := duk_get_length(FContext, AIndex);
end;

function TDuktape.GetInt(const AIndex: Integer): Integer;
begin
  Result := duk_get_int(FContext, AIndex);
end;

function TDuktape.GetMagic(const AIndex: Integer): Integer;
begin
  Result := duk_get_magic(FContext, AIndex);
end;

function TDuktape.GetMemoryManagementFunctions: TdtMemoryFunctions;
begin
  duk_get_memory_functions(FContext, @Result);
end;

function TDuktape.GetNumber(const AIndex: Integer): Double;
begin
  Result := duk_get_number(FContext, AIndex);
end;

function TDuktape.GetNow: Double;
begin
  Result := duk_get_now(FContext);
end;

function TDuktape.GetNumber(const AIndex: Integer;
  const ADefault: Double): Double;
begin
  Result := duk_get_number_default(FContext, AIndex, ADefault);
end;

function TDuktape.GetPointer(const AIndex: Integer;
  const ADefault: Pointer): Pointer;
begin
  Result := duk_get_pointer_default(FContext, AIndex, ADefault);
end;

function TDuktape.GetProp(const AObjIndex: Integer): Boolean;
begin
  Result := (duk_get_prop(FContext, AObjIndex) <> 0);
end;

procedure TDuktape.GetPropDesc(const AObjIndex: Integer);
begin
  duk_get_prop_desc(FContext, AObjIndex, 0);
end;

procedure TDuktape.GetPrototype(const AIndex: Integer);
begin
  duk_get_prototype(FContext, AIndex);
end;

function TDuktape.GetProp(const AObjIndex, AArrIndex: Integer): Boolean;
begin
  Result := (duk_get_prop_index(FContext, AObjIndex, AArrIndex) <> 0);
end;

function TDuktape.GetProp(const AObjIndex: Integer;
  const AKey: DuktapeString): Boolean;
begin
  Result := (duk_get_prop_string(FContext, AObjIndex, MarshaledAString(AKey)) <> 0);
end;

function TDuktape.GetProp(const AObjIndex: Integer;
  const APtr: Pointer): Boolean;
begin
  Result := (duk_get_prop_heapptr(FContext, AObjIndex, APtr) <> 0);
end;

function TDuktape.GetPointer(const AIndex: Integer): Pointer;
begin
  Result := duk_get_pointer(FContext, AIndex);
end;

function TDuktape.GetString(const AIndex: Integer;
  const ADefault: DuktapeString): DuktapeString;
begin
  Result := DuktapeString(duk_get_string_default(FContext, AIndex,
    MarshaledAString(ADefault)));
end;

function TDuktape.GetString(const AIndex: Integer): DuktapeString;
begin
  Result := DuktapeString(duk_get_string(FContext, AIndex));
end;

function TDuktape.GetTop: Integer;
begin
  Result := duk_get_top(FContext);
end;

function TDuktape.GetTopIndex: Integer;
begin
  Result := duk_get_top_index(FContext);
end;

function TDuktape.GetType(const AIndex: Integer): TdtType;
begin
  Result := TdtType(duk_get_type(FContext, AIndex));
end;

function TDuktape.GetTypes(const AIndex: Integer): TdtTypes;
begin
  Result := TdtTypes(Word(duk_get_type_mask(FContext, AIndex)));
end;

function TDuktape.GetUInt(const AIndex: Integer;
  const ADefault: Cardinal): Cardinal;
begin
  Result := duk_get_uint_default(FContext, AIndex, ADefault);
end;

function TDuktape.HasProp(const AObjIndex: Integer): Boolean;
begin
  Result := (duk_has_prop(FContext, AObjIndex) <> 0);
end;

function TDuktape.HasProp(const AObjIndex, AArrIndex: Integer): Boolean;
begin
  Result := (duk_has_prop_index(FContext, AObjIndex, AArrIndex) <> 0);
end;

function TDuktape.HasProp(const AObjIndex: Integer;
  const AKey: DuktapeString): Boolean;
begin
  Result := (duk_has_prop_string(FContext, AObjIndex, MarshaledAString(AKey)) <> 0);
end;

function TDuktape.HasProp(const AObjIndex: Integer;
  const APtr: Pointer): Boolean;
begin
  Result := (duk_has_prop_heapptr(FContext, AObjIndex, APtr) <> 0);
end;

procedure TDuktape.HexDecode(const AIndex: Integer);
begin
  duk_hex_decode(FContext, AIndex);
end;

function TDuktape.HexEncode(const AIndex: Integer): DuktapeString;
begin
  Result := DuktapeString(duk_hex_encode(FContext, AIndex));
end;

function TDuktape.GetUInt(const AIndex: Integer): Cardinal;
begin
  Result := duk_get_uint(FContext, AIndex);
end;

procedure TDuktape.Insert(const AToIndex: Integer);
begin
  duk_insert(FContext, AToIndex);
end;

procedure TDuktape.InspectCallstackEntry(const ALevel: Integer);
begin
  duk_inspect_callstack_entry(FContext, ALevel);
end;

procedure TDuktape.InspectValue(const AIndex: Integer);
begin
  duk_inspect_value(FContext, AIndex);
end;

function TDuktape.InstanceOf(const AIndex1, AIndex2: Integer): Boolean;
begin
  Result := (duk_instanceof(FContext, AIndex1, AIndex2) <> 0);
end;

function TDuktape.IsArray(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_array(FContext, AIndex) <> 0);
end;

function TDuktape.IsBoolean(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_boolean(FContext, AIndex) <> 0);
end;

function TDuktape.IsBoundFunction(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_bound_function(FContext, AIndex) <> 0);
end;

function TDuktape.IsBuffer(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_buffer(FContext, AIndex) <> 0);
end;

function TDuktape.IsBufferData(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_buffer_data(FContext, AIndex) <> 0);
end;

function TDuktape.IsCallable(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_callable(FContext, AIndex) <> 0);
end;

function TDuktape.IsConstructable(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_constructable(FContext, AIndex) <> 0);
end;

function TDuktape.IsConstructorCall: Boolean;
begin
  Result := (duk_is_constructor_call(FContext) <> 0);
end;

function TDuktape.IsDelphiFunction(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_c_function(FContext, AIndex) <> 0);
end;

function TDuktape.IsDynamicBuffer(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_dynamic_buffer(FContext, AIndex) <> 0);
end;

function TDuktape.IsEcmaScriptFunction(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_ecmascript_function(FContext, AIndex) <> 0);
end;

function TDuktape.IsError(const AIndex: Integer): Boolean;
begin
  Result := duk_is_error(FContext, AIndex);
end;

function TDuktape.IsEvalError(const AIndex: Integer): Boolean;
begin
  Result := duk_is_eval_error(FContext, AIndex);
end;

function TDuktape.IsExternalBuffer(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_external_buffer(FContext, AIndex) <> 0);
end;

function TDuktape.IsFixedBuffer(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_fixed_buffer(FContext, AIndex) <> 0);
end;

function TDuktape.IsFunction(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_function(FContext, AIndex) <> 0);
end;

function TDuktape.IsLightFunc(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_lightfunc(FContext, AIndex) <> 0);
end;

function TDuktape.IsNan(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_nan(FContext, AIndex) <> 0);
end;

function TDuktape.IsNull(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_null(FContext, AIndex) <> 0);
end;

function TDuktape.IsNullOrUndefined(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_null_or_undefined(FContext, AIndex) <> 0);
end;

function TDuktape.IsNumber(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_number(FContext, AIndex) <> 0);
end;

function TDuktape.IsObject(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_object(FContext, AIndex) <> 0);
end;

function TDuktape.IsObjectCoercible(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_object_coercible(FContext, AIndex) <> 0);
end;

function TDuktape.IsPointer(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_pointer(FContext, AIndex) <> 0);
end;

function TDuktape.IsPrimitive(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_primitive(FContext, AIndex) <> 0);
end;

function TDuktape.IsRangeError(const AIndex: Integer): Boolean;
begin
  Result := duk_is_range_error(FContext, AIndex);
end;

function TDuktape.IsReferenceError(const AIndex: Integer): Boolean;
begin
  Result := duk_is_reference_error(FContext, AIndex);
end;

function TDuktape.IsStrictCall: Boolean;
begin
  Result := (duk_is_strict_call(FContext) <> 0);
end;

function TDuktape.IsString(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_string(FContext, AIndex) <> 0);
end;

function TDuktape.IsSymbol(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_symbol(FContext, AIndex) <> 0);
end;

function TDuktape.IsSyntaxError(const AIndex: Integer): Boolean;
begin
  Result := duk_is_syntax_error(FContext, AIndex);
end;

function TDuktape.IsThread(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_thread(FContext, AIndex) <> 0);
end;

function TDuktape.IsTypeError(const AIndex: Integer): Boolean;
begin
  Result := duk_is_type_error(FContext, AIndex);
end;

function TDuktape.IsUndefined(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_undefined(FContext, AIndex) <> 0);
end;

function TDuktape.IsUriError(const AIndex: Integer): Boolean;
begin
  Result := duk_is_uri_error(FContext, AIndex);
end;

function TDuktape.IsValidIndex(const AIndex: Integer): Boolean;
begin
  Result := (duk_is_valid_index(FContext, AIndex) <> 0);
end;

procedure TDuktape.Join(const ACount: Integer);
begin
  duk_join(FContext, ACount);
end;

procedure TDuktape.JsonDecode(const AIndex: Integer);
begin
  duk_json_decode(FContext, AIndex);
end;

function TDuktape.JsonEncode(const AIndex: Integer): DuktapeString;
begin
  Result := DuktapeString(duk_json_encode(FContext, AIndex));
end;

procedure TDuktape.LoadFunction;
begin
  duk_load_function(FContext);
end;

procedure TDuktape.MapString(const AIndex: Integer;
  const ACallback: TdtMapCharCallback; const AUserData: Pointer);
begin
  duk_map_string(FContext, AIndex, TDukMapCharFunction(ACallback), AUserData);
end;

procedure TDuktape.New(const ANumArgs: Integer);
begin
  duk_new(FContext, ANumArgs);
end;

function TDuktape.Next(const AEnumIndex: Integer;
  const AGetValue: Boolean): Boolean;
begin
  Result := (duk_next(FContext, AEnumIndex, Ord(AGetValue)) <> 0);
end;

function TDuktape.NormalizeIndex(const AIndex: Integer): Integer;
begin
  Result := duk_normalize_index(FContext, AIndex);
end;

function TDuktape.OptBoolean(const AIndex: Integer;
  const ADefault: Boolean): Boolean;
begin
  Result := (duk_opt_boolean(FContext, AIndex, Ord(ADefault)) <> 0);
end;

function TDuktape.OptBuffer(const AIndex: Integer; out ASize: NativeInt;
  const ADefault: Pointer; const ADefaultSize: NativeInt): Pointer;
begin
  Result := duk_opt_buffer(FContext, AIndex, @ASize, ADefault, ADefaultSize);
end;

function TDuktape.OptBufferData(const AIndex: Integer; out ASize: NativeInt;
  const ADefault: Pointer; const ADefaultSize: NativeInt): Pointer;
begin
  Result := duk_opt_buffer_data(FContext, AIndex, @ASize, ADefault, ADefaultSize);
end;

function TDuktape.OptContext(const AIndex: Integer;
  const ADefault: TDuktape): TDuktape;
begin
  Result.FContext := duk_opt_context(FContext, AIndex, ADefault.FContext);
end;

function TDuktape.OptHeapPtr(const AIndex: Integer;
  const ADefault: Pointer): Pointer;
begin
  Result := duk_opt_heapptr(FContext, AIndex, ADefault);
end;

function TDuktape.OptInt(const AIndex, ADefault: Integer): Integer;
begin
  Result := duk_opt_int(FContext, AIndex, ADefault);
end;

function TDuktape.OptNumber(const AIndex: Integer;
  const ADefault: Double): Double;
begin
  Result := duk_opt_number(FContext, AIndex, ADefault);
end;

function TDuktape.OptPointer(const AIndex: Integer;
  const ADefault: Pointer): Pointer;
begin
  Result := duk_opt_pointer(FContext, AIndex, ADefault);
end;

function TDuktape.OptString(const AIndex: Integer;
  const ADefault: DuktapeString): DuktapeString;
begin
  Result := DuktapeString(duk_opt_string(FContext, AIndex,
    MarshaledAString(ADefault)));
end;

function TDuktape.OptUInt(const AIndex: Integer;
  const ADefault: Cardinal): Cardinal;
begin
  Result := duk_opt_uint(FContext, AIndex, ADefault);
end;

procedure TDuktape.Pop(const ACount: Integer);
begin
  duk_pop_n(FContext, ACount);
end;

procedure TDuktape.Pop;
begin
  duk_pop(FContext);
end;

procedure TDuktape.Pop2;
begin
  duk_pop_2(FContext);
end;

procedure TDuktape.Pop3;
begin
  duk_pop_3(FContext);
end;

function TDuktape.ProtectedCall(const ANumArgs: Integer): Integer;
begin
  Result := duk_pcall(FContext, ANumArgs);
end;

function TDuktape.ProtectedCallMethod(const ANumArgs: Integer): Integer;
begin
  Result := duk_pcall_method(FContext, ANumArgs);
end;

function TDuktape.ProtectedCallProp(const AObjIndex, ANumArgs: Integer): Integer;
begin
  Result := duk_pcall_prop(FContext, AObjIndex, ANumArgs);
end;

function TDuktape.ProtectedCompile(const AFlags: TdtCompileFlags;
  const ASource: DuktapeString): Integer;
begin
  Result := duk_pcompile_lstring(FContext, Word(AFlags),
    MarshaledAString(ASource), Length(ASource));
end;

function TDuktape.ProtectedCompile(const AFlags: TdtCompileFlags): Integer;
begin
  Result := duk_pcompile(FContext, Word(AFlags));
end;

function TDuktape.ProtectedCompileFilename(const AFlags: TdtCompileFlags;
  const ASource: DuktapeString): Integer;
begin
  Result := duk_pcompile_lstring_filename(FContext, Word(AFlags),
    MarshaledAString(ASource), Length(ASource));
end;

function TDuktape.ProtectedEval(const ASource: DuktapeString): Integer;
begin
  Result := duk_peval_lstring(FContext, MarshaledAString(ASource), Length(ASource));
end;

function TDuktape.ProtectedEval: Integer;
begin
  Result := duk_peval(FContext);
end;

function TDuktape.ProtectedEvalNoResult(const ASource: DuktapeString): Integer;
begin
  Result := duk_peval_lstring_noresult(FContext, MarshaledAString(ASource), Length(ASource));
end;

function TDuktape.ProtectedEvalNoResult: Integer;
begin
  Result := duk_peval_noresult(FContext);
end;

function TDuktape.ProtectedNew(const ANumArgs: Integer): Integer;
begin
  Result := duk_pnew(FContext, ANumArgs);
end;

function TDuktape.PushArray: Integer;
begin
  Result := duk_push_array(FContext);
end;

function TDuktape.PushBareObject: Integer;
begin
  Result := duk_push_bare_object(FContext);
end;

procedure TDuktape.PushBoolean(const AValue: Boolean);
begin
  duk_push_boolean(FContext, Ord(AValue));
end;

function TDuktape.PushBuffer(const ASize: NativeInt;
  const AIsDynamic: Boolean): Pointer;
begin
  Result := duk_push_buffer(FContext, ASize, AIsDynamic);
end;

procedure TDuktape.PushBufferObject(const ABufferIndex: Integer;
  const AByteOffset, AByteLength: NativeInt; const AType: TdtBufferType);
begin
  duk_push_buffer_object(FContext, ABufferIndex, AByteOffset, AByteLength,
    Ord(AType));
end;

procedure TDuktape.PushContextDump;
begin
  duk_push_context_dump(FContext);
end;

procedure TDuktape.PushCurrentFunction;
begin
  duk_push_current_function(FContext);
end;

procedure TDuktape.PushCurrentThread;
begin
  duk_push_current_thread(FContext);
end;

function TDuktape.PushDynamicBuffer(const ASize: NativeInt): Pointer;
begin
  Result := duk_push_dynamic_buffer(FContext, ASize);
end;

function TDuktape.PushErrorObject(const AErrCode: TdtErrcode;
  const AErrMsg: DuktapeString): Integer;
begin
  Result := duk_push_error_object(FContext, Ord(AErrCode), MarshaledAString(AErrMsg));
end;

function TDuktape.PushExternalBuffer: Pointer;
begin
  Result := duk_push_external_buffer(FContext);
end;

procedure TDuktape.PushFalse;
begin
  duk_push_false(FContext);
end;

function TDuktape.PushFixedBuffer(const ASize: NativeInt): Pointer;
begin
  Result := duk_push_fixed_buffer(FContext, ASize);
end;

procedure TDuktape.PushGlobalObject;
begin
  duk_push_global_object(FContext);
end;

procedure TDuktape.PushGlobalStash;
begin
  duk_push_global_stash(FContext);
end;

function TDuktape.PushHeapPtr(const APtr: Pointer): Integer;
begin
  Result := duk_push_heapptr(FContext, APtr);
end;

procedure TDuktape.PushHeapStash;
begin
  duk_push_heap_stash(FContext);
end;

procedure TDuktape.PushInt(const AValue: Integer);
begin
  duk_push_int(FContext, AValue);
end;

procedure TDuktape.PushNan;
begin
  duk_push_nan(FContext);
end;

procedure TDuktape.PushNull;
begin
  duk_push_null(FContext);
end;

procedure TDuktape.PushNumber(const AValue: Double);
begin
  duk_push_number(FContext, AValue);
end;

function TDuktape.PushObject: Integer;
begin
  Result := duk_push_object(FContext);
end;

procedure TDuktape.PushPointer(const AValue: Pointer);
begin
  duk_push_pointer(FContext, AValue);
end;

function TDuktape.PushProxy(const AFlags: Cardinal): Integer;
begin
  Result := duk_push_proxy(FContext, AFlags);
end;

function TDuktape.PushString(const AString: DuktapeString): MarshaledAString;
begin
  Result := duk_push_lstring(FContext, MarshaledAString(AString), Length(AString));
end;

procedure TDuktape.PushThis;
begin
  duk_push_this(FContext);
end;

function TDuktape.PushThread: Integer;
begin
  Result := duk_push_thread(FContext);
end;

function TDuktape.PushThreadNewGlobalEnv: Integer;
begin
  Result := duk_push_thread_new_globalenv(FContext);
end;

procedure TDuktape.PushThreadStash(const ATargetContext: TDuktape);
begin
  duk_push_thread_stash(FContext, ATargetContext.FContext);
end;

procedure TDuktape.PushTrue;
begin
  duk_push_true(FContext);
end;

procedure TDuktape.PushUInt(const AValue: Cardinal);
begin
  duk_push_uint(FContext, AValue);
end;

procedure TDuktape.PushUndefined;
begin
  duk_push_undefined(FContext);
end;

procedure TDuktape.PutFunctionList(const AObjIndex: Integer;
  const AFunctions: PdtFunctionListEntry);
begin
  duk_put_function_list(FContext, AObjIndex, AFunctions);
end;

function TDuktape.PutGlobalString(const AKey: DuktapeString): Boolean;
begin
  Result := (duk_put_global_lstring(FContext, MarshaledAString(AKey),
    Length(AKey)) <> 0);
end;

procedure TDuktape.PutNumberList(const AObjIndex: Integer;
  const ANumbers: PdtNumberListEntry);
begin
  duk_put_number_list(FContext, AObjIndex, ANumbers);
end;

function TDuktape.PutProp(const AObjIndex: Integer): Boolean;
begin
  Result := (duk_put_prop(FContext, AObjIndex) <> 0);
end;

function TDuktape.PutProp(const AObjIndex, AArrIndex: Integer): Boolean;
begin
  Result := (duk_put_prop_index(FContext, AObjIndex, AArrIndex) <> 0);
end;

function TDuktape.PutProp(const AObjIndex: Integer;
  const AKey: DuktapeString): Boolean;
begin
  Result := (duk_put_prop_string(FContext, AObjIndex, MarshaledAString(AKey)) <> 0);
end;

function TDuktape.PutProp(const AObjIndex: Integer;
  const APtr: Pointer): Boolean;
begin
  Result := (duk_put_prop_heapptr(FContext, AObjIndex, APtr) <> 0);
end;

procedure TDuktape.RangeError(const AErrMsg: DuktapeString);
begin
  duk_range_error(FContext, MarshaledAString(AErrMsg));
end;

function TDuktape.ReallocMem(const APtr: Pointer;
  const ASize: NativeInt): Pointer;
begin
  Result := duk_realloc(FContext, APtr, ASize);
end;

function TDuktape.ReallocRaw(const APtr: Pointer;
  const ASize: NativeInt): Pointer;
begin
  Result := duk_realloc_raw(FContext, APtr, ASize);
end;

procedure TDuktape.ReferenceError(const AErrMsg: DuktapeString);
begin
  duk_reference_error(FContext, MarshaledAString(AErrMsg));
end;

procedure TDuktape.Remove(const AIndex: Integer);
begin
  duk_remove(FContext, AIndex);
end;

procedure TDuktape.Replace(const AToIndex: Integer);
begin
  duk_replace(FContext, AToIndex);
end;

function TDuktape.RequireBoolean(const AIndex: Integer): Boolean;
begin
  Result := (duk_require_boolean(FContext, AIndex) <> 0);
end;

function TDuktape.RequireBuffer(const AIndex: Integer;
  out ASize: NativeInt): Pointer;
begin
  Result := duk_require_buffer(FContext, AIndex, @ASize);
end;

function TDuktape.RequireBufferData(const AIndex: Integer;
  out ASize: NativeInt): Pointer;
begin
  Result := duk_require_buffer_data(FContext, AIndex, @ASize);
end;

procedure TDuktape.RequireCallable(const AIndex: Integer);
begin
  duk_require_callable(FContext, AIndex);
end;

function TDuktape.RequireContext(const AIndex: Integer): TDuktape;
begin
  Result.FContext := duk_require_context(FContext, AIndex);
end;

procedure TDuktape.RequireFunction(const AIndex: Integer);
begin
  duk_require_function(FContext, AIndex);
end;

function TDuktape.RequireHeapPtr(const AIndex: Integer): Pointer;
begin
  Result := duk_require_heapptr(FContext, AIndex);
end;

function TDuktape.RequireInt(const AIndex: Integer): Integer;
begin
  Result := duk_require_int(FContext, AIndex);
end;

function TDuktape.RequireNormalizeIndex(const AIndex: Integer): Integer;
begin
  Result := duk_require_normalize_index(FContext, AIndex);
end;

procedure TDuktape.RequireNull(const AIndex: Integer);
begin
  duk_require_null(FContext, AIndex);
end;

function TDuktape.RequireNumber(const AIndex: Integer): Double;
begin
  Result := duk_require_number(FContext, AIndex);
end;

procedure TDuktape.RequireObject(const AIndex: Integer);
begin
  duk_require_object(FContext, AIndex);
end;

procedure TDuktape.RequireObjectCoercible(const AIndex: Integer);
begin
  duk_require_object_coercible(FContext, AIndex);
end;

function TDuktape.RequirePointer(const AIndex: Integer): Pointer;
begin
  Result := duk_require_pointer(FContext, AIndex);
end;

procedure TDuktape.RequireStack(const AExtra: Integer);
begin
  duk_require_stack(FContext, AExtra);
end;

procedure TDuktape.RequireStackTop(const ATop: Integer);
begin
  duk_require_stack_top(FContext, ATop);
end;

function TDuktape.RequireString(const AIndex: Integer): DuktapeString;
begin
  Result := DuktapeString(duk_require_string(FContext, AIndex));
end;

function TDuktape.RequireTopIndex: Integer;
begin
  Result := duk_require_top_index(FContext);
end;

procedure TDuktape.RequireTypes(const AIndex: Integer; const ATypes: TdtTypes);
begin
  duk_require_type_mask(FContext, AIndex, Word(ATypes));
end;

function TDuktape.RequireUInt(const AIndex: Integer): Cardinal;
begin
  Result := duk_require_uint(FContext, AIndex);
end;

procedure TDuktape.RequireUndefined(const AIndex: Integer);
begin
  duk_require_undefined(FContext, AIndex);
end;

procedure TDuktape.RequireValidIndex(const AIndex: Integer);
begin
  duk_require_valid_index(FContext, AIndex);
end;

function TDuktape.Resize_buffer(const AIndex: Integer;
  const ANewSize: NativeInt): Pointer;
begin
  Result := duk_resize_buffer(FContext, AIndex, ANewSize);
end;

procedure TDuktape.Resume(const AState: TdtThreadState);
begin
  duk_resume(FContext, @AState);
end;

function TDuktape.SafeToString(const AIndex: Integer): DuktapeString;
begin
  Result := DuktapeString(duk_safe_to_string(FContext, AIndex));
end;

function TDuktape.SameValue(const AIndex1, AIndex2: Integer): Boolean;
begin
  Result := (duk_samevalue(FContext, AIndex1, AIndex2) <> 0);
end;

procedure TDuktape.Seal(const AObjIndex: Integer);
begin
  duk_seal(FContext, AObjIndex);
end;

procedure TDuktape.SetFinalizer(const AIndex: Integer);
begin
  duk_set_finalizer(FContext, AIndex);
end;

procedure TDuktape.SetGlobalObject;
begin
  duk_set_global_object(FContext);
end;

procedure TDuktape.SetLength(const AIndex: Integer; const ALength: NativeInt);
begin
  duk_set_length(FContext, AIndex, ALength);
end;

procedure TDuktape.SetMagic(const AIndex, AMagic: Integer);
begin
  duk_set_magic(FContext, AIndex, AMagic);
end;

procedure TDuktape.SetPrototype(const AIndex: Integer);
begin
  duk_set_prototype(FContext, AIndex);
end;

procedure TDuktape.SetTop(const AIndex: Integer);
begin
  duk_set_top(FContext, AIndex);
end;

function TDuktape.StealBuffer(const AIndex: Integer;
  out ASize: NativeInt): Pointer;
begin
  Result := duk_steal_buffer(FContext, AIndex, @ASize);
end;

function TDuktape.StrictEquals(const AIndex1, AIndex2: Integer): Boolean;
begin
  Result := (duk_strict_equals(FContext, AIndex1, AIndex2) <> 0);
end;

procedure TDuktape.SubString(const AIndex: Integer; const AStartCharOffset,
  AEndCharOffset: NativeInt);
begin
  duk_substring(FContext, AIndex, AStartCharOffset, AEndCharOffset);
end;

function TDuktape.Suspend: TdtThreadState;
begin
  duk_suspend(FContext, @Result);
end;

procedure TDuktape.Swap(const AIndex1, AIndex2: Integer);
begin
  duk_swap(FContext, AIndex1, AIndex2);
end;

procedure TDuktape.SwapTop(const AIndex: Integer);
begin
  duk_swap_top(FContext, AIndex);
end;

procedure TDuktape.SyntaxError(const AErrMsg: DuktapeString);
begin
  duk_syntax_error(FContext, MarshaledAString(AErrMsg));
end;

procedure TDuktape.Throw;
begin
  duk_throw(FContext);
end;

function TDuktape.TimeToComponents(const ATimeVal: Double): TdtTimeComponents;
begin
  duk_time_to_components(FContext, ATimeVal, @Result);
end;

function TDuktape.ToBoolean(const AIndex: Integer): Boolean;
begin
  Result := (duk_to_boolean(FContext, AIndex) <> 0);
end;

function TDuktape.ToBuffer(const AIndex: Integer;
  out ASize: NativeInt): Pointer;
begin
  Result := duk_to_buffer(FContext, AIndex, @ASize);
end;

function TDuktape.ToDynamicBuffer(const AIndex: Integer;
  out ASize: NativeInt): Pointer;
begin
  Result := duk_to_dynamic_buffer(FContext, AIndex, @ASize);
end;

function TDuktape.ToFixedBuffer(const AIndex: Integer;
  out ASize: NativeInt): Pointer;
begin
  Result := duk_to_fixed_buffer(FContext, AIndex, @ASize);
end;

function TDuktape.ToInt(const AIndex: Integer): Integer;
begin
  Result := duk_to_int(FContext, AIndex);
end;

function TDuktape.ToInt32(const AIndex: Integer): Integer;
begin
  Result := duk_to_int32(FContext, AIndex);
end;

procedure TDuktape.ToNull(const AIndex: Integer);
begin
  duk_to_null(FContext, AIndex);
end;

function TDuktape.ToNumber(const AIndex: Integer): Double;
begin
  Result := duk_to_number(FContext, AIndex);
end;

procedure TDuktape.ToObject(const AIndex: Integer);
begin
  duk_to_object(FContext, AIndex);
end;

function TDuktape.ToPointer(const AIndex: Integer): Pointer;
begin
  Result := duk_to_pointer(FContext, AIndex);
end;

procedure TDuktape.ToPrimitive(const AIndex: Integer; const AHint: TdtHint);
begin
  duk_to_primitive(FContext, AIndex, Ord(AHint));
end;

function TDuktape.ToString(const AIndex: Integer): DuktapeString;
begin
  Result := DuktapeString(duk_to_string(FContext, AIndex));
end;

function TDuktape.ToUInt(const AIndex: Integer): Cardinal;
begin
  Result := duk_to_uint(FContext, AIndex);
end;

function TDuktape.ToUInt16(const AIndex: Integer): UInt16;
begin
  Result := duk_to_uint16(FContext, AIndex);
end;

function TDuktape.ToUInt32(const AIndex: Integer): Cardinal;
begin
  Result := duk_to_uint32(FContext, AIndex);
end;

procedure TDuktape.ToUndefined(const AIndex: Integer);
begin
  duk_to_undefined(FContext, AIndex);
end;

procedure TDuktape.TypeError(const AErrMsg: DuktapeString);
begin
  duk_type_error(FContext, MarshaledAString(AErrMsg));
end;

procedure TDuktape.UriError(const AErrMsg: DuktapeString);
begin
  duk_uri_error(FContext, MarshaledAString(AErrMsg));
end;

procedure TDuktape.XCopyTop(const AToContext: TDuktape; const ACount: Integer);
begin
  duk_xcopy_top(AToContext.FContext, FContext, ACount);
end;

procedure TDuktape.XMoveTop(const AToContext: TDuktape; const ACount: Integer);
begin
  duk_xmove_top(AToContext.FContext, FContext, ACount);
end;

{ TDuktapeHelper }

function TDuktapeHelper.GetDelphiFunction(
  const AIndex: Integer): TdtDelphiFunction;
begin
  Result := TdtDelphiFunction(duk_get_c_function(FContext, AIndex));
end;

procedure TDuktapeHelper.DebuggerAttach(
  const AReadCallback: TdtDebugReadCallback;
  const AWriteCallback: TdtDebugWriteCallback;
  const APeekCallback: TdtDebugPeekCallback;
  const AReadFlushCallback: TdtDebugReadFlushCallback;
  const AWriteFlushCallback: TdtDebugWriteFlushCallback;
  const ARequestCallback: TdtDebugRequestCallback;
  const ADetachedCallback: TdtDebugDetachedCallback; const AUserData: Pointer);
begin
  duk_debugger_attach(FContext,
    TDukDebugReadFunction(AReadCallback),
    TDukDebugWriteFunction(AWriteCallback),
    TDukDebugPeekFunction(APeekCallback),
    TDukDebugReadFlushFunction(AReadFlushCallback),
    TDukDebugWriteFlushFunction(AWriteFlushCallback),
    TDukDebugRequestFunction(ARequestCallback),
    TDukDebugDetachedFunction(ADetachedCallback),
    AUserData);
end;

function TDuktapeHelper.GetDelphiFunction(const AIndex: Integer;
  const ADefault: TdtDelphiFunction): TdtDelphiFunction;
begin
  Result := TdtDelphiFunction(duk_get_c_function_default(FContext, AIndex,
    TDukCFunction(ADefault)));
end;

function TDuktapeHelper.OptDelphiFunction(const AIndex: Integer;
  const ADefault: TdtDelphiFunction): TdtDelphiFunction;
begin
  Result := TdtDelphiFunction(duk_opt_c_function(FContext, AIndex,
    TDukCFunction(ADefault)));
end;

function TDuktapeHelper.PushDelphiFunction(const AFunc: TdtDelphiFunction;
  const ANumArgs: Integer): Integer;
begin
  Result := duk_push_c_function(FContext, TDukCFunction(AFunc), ANumArgs);
end;

function TDuktapeHelper.PushDelphiLightFunction(const AFunc: TdtDelphiFunction;
  const ANumArgs, ALength, AMagic: Integer): Integer;
begin
  Result := duk_push_c_lightfunc(FContext, TDukCFunction(AFunc), ANumArgs,
    ALength, AMagic);
end;

function TDuktapeHelper.RequireDelphiFunction(
  const AIndex: Integer): TdtDelphiFunction;
begin
  Result := TdtDelphiFunction(duk_require_c_function(FContext, AIndex));
end;

function TDuktapeHelper.SafeCall(const AFunc: TdtSafeCallFunction;
  const AUserData: Pointer; const ANumArgs, ANumReturns: Integer): Integer;
begin
  Result := duk_safe_call(FContext, TDukSafeCallFunction(AFunc), AUserData,
    ANumArgs, ANumReturns);
end;

end.
